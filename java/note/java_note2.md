# java note2 面向对象

面向过程(POP:Procedure Oriented Programming)与面向对象(OOP:Object Oriented Programming):
二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。

面向对象的三大特征:

- 封装 (Encapsulation)
- 继承 (Inheritance)
- 多态 (Polymorphism)

## Java类以及类的成员

- 类:类是对一类事物的描述，是抽象的、概念上的定义
- 对象对象是实际存在的该类事物的每个个体，因而也称为实例(instance)

### 类的成员

设计一个类:

- 属性:成员变量
- 方法:成员方法

### 实例化

`Class instance = new Class()`

- 匿名对象:`new Class()`

### 调用

`instance.attribute = ...`
`instance.method(args)`

### 属性

```md
权限修饰符 数据类型 属性名 = 默认值;
```

- 属性的默认初始化值与数组中的相同

### 方法

```md
权限修饰符 返回值类型 方法名 (形参列表) {
    方法体
}
```

- 可以调用当前类的属性和方法
- 方法中不可以再定义方法
- 形参列表中不可以有默认值(区别于C++)

方法重载:

- 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。

可变个数的形参:

- 允许直接定义能和多个实参相匹配的形参。格式:方法名(数据类型...参数名),如:`public static void test(int a, String...strs)`
- 可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个
- 可变个数形参的方法与同名的方法之间，彼此构成重载
- 可变参数方法的使用与方法参数部分使用数组是一致的,如上例相等于`public static void test(int a, String[] strs)`
- 方法的参数部分有可变形参，需要放在形参声明的最后
- 在一个方法的形参位置，最多只能声明一个可变个数形参

方法参数的值传递机制(值传递):

- 对于基本数据类型:将数据值传递给形参
- 对于引用数据类型:将地址值传递给形参

递归:一个方法体内调用它自身。

### 封装性

封装性:隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用.

封装性体现:

- 将数据声明为私有的(private)，再提供公共的（public）方法:getXxx()和setXxx()实现对该属性的操作
- 将类方法中常用的方法抽象为工具方法,声明为私有的

权限修饰符:

| 修饰符    | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 |
| --------- | ------ | -------- | ------------ | ---------- |
| private   | √      | ×        | ×            | ×          |
| 缺省      | √      | ×        | ×            | ×          |
| protected | √      | √        | √            | ×          |
| public    | √      | √        | √            | √          |

- 4种权限修饰符都可以修饰类的内部结构：属性,方法,构造器,内部类
- 修饰类只能用public和private

### 构造器(构造方法)

创建类:new + 构造器,相当于C++的构造函数

作用：

- 创建对象
- 给对象进行初始化

构造器的特征:

- 它具有与类相同的名称
- 它不声明返回值类型。（与声明为void不同）
- 不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值

种类:

- 隐式无参构造器（系统默认提供）
- 显式定义一个或多个构造器（无参、有参）

注意:

- Java语言中，每个类都至少有一个构造器
- 默认构造器的修饰符与所属类的修饰符一致
- 一旦显式定义了构造器，则系统不再提供默认构造器
- 父类的构造器不可被子类继承

### JavaBean

JavaBean是指符合以下标准的Java类:

- 类是公共的
- 有一个无参的公共的构造器
- 有属性，且有对应的get、set方法

### this关键字

this指的是当前的对象或正在构造的对象

- 调用属性,方法:
  - 调用当前对象的属性
  - 调用当前对象的方法
  - 我们可以用this来区分属性和局部变量,如`this.name = name`
- 调用构造器:
  - 如在另一个构造器中调用`this()`可以调用本类中的无参构造器
  - 此时`this(形参列表)`应放在首行
- 直接调用当前对象

### package关键字

package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。

- 格式为:`package 顶层包名.子包名`
- MVC设计模式:MVC是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，与数据模型层。
- JDK中主要的包介绍
  - java.lang 包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能
  - java.net 与网络相关的的类和接口
  - java.io 提供多种输入/输出功能的类
  - java.util 包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。
  - java.text 包含了一些java格式化相关的类
  - java.sql 包含了java进行JDBC数据库编程的相关类/接口

### import关键字

为使用定义在不同包中的Java类，需用import语句来引入指定包层次下所需要的类或全部类(*)

- 格式：`import 包名. 类名;`
- 如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。
- 如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的是哪个类。
- 如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。
- import static组合的使用：调用指定类或接口下的静态的属性或方法

## 继承性和多态性

### 继承性

继承:多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。子类继承了父类，就继承了父类的方法和属性。

语法规则:class Subclass extends SuperClass{ }

作用：

- 继承的出现减少了代码冗余，提高了代码的复用性。
- 继承的出现，更有利于功能的扩展。
- 继承的出现让类与类之间产生了关系，提供了多态的前提.

注意:

- Java只支持单继承和多层继承，不允许多重继承
- 如果我们没有显式地声明一个类地父类的话,则该类继承java.lang.Object类

### 方法的重写

在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。

要求：

- 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表
- 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型
- 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限,子类不能重写父类中声明为private权限的方法
- 子类方法抛出的异常不能大于父类被重写方法的异常
- 子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。

### super关键字

super表示调用直接父类父类或间接父类

- 访问父类中定义的属性
- 调用父类中定义的成员方法
  - 当子父类出现同名成员时(重写时)，可以用super表明调用的是父类中的成员
- 在子类构造器中调用父类的构造器`super(形参列表)`
  - 子类中所有的构造器默认都会访问父类中空参数的构造器super()
  - 当父类中没有空参数的构造器时，子类的构造器必须通过this(参
数列表)或者super(参数列表)语句指定调用本类或者父类中相应的
构造器，且必须放在构造器的首行(因为在构造子类之前,先要构造父类)

### 子类对象实例化过程

当我们通过子类的构造器创建子类对象,我们一定或间接地调用了父类的构造器,直到调用到Object的空参构造器为止

注意:

- 虽然子类构造器调用了父类的构造器,但是只创建了一个对象

### 多态性

父类的引用指向子类的对象:`ParentClass p = new ChildClass()`

编译时类型与运行时类型:编译时的类型由声明该变量的类型决定,运行时实际由赋予该变量的对象决定,编译看左边,运行看右边.编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)实现通用性

虚拟方法调用:子类中定义了与父类同名同参数的方法(重写)，在多态情况下，此时父类的方法称为虚拟方法，因为父类根据赋给它的不同子类对象，动态调用属于子类的该方法。如上例ParentClass和ChildClass都定义了method(),则`p.method()`执行的是ChildClass类的method().这样的方法调用在编译期是无法确定的(动态绑定)。

注意:

- 多态性仅对于方法而言,成员变量不具备多态性
- 内存中实际加载了子类的属性和方法,但由于变量被声明为父类类型,此时父类不能调用子类的方法和属性

向下转型:使用强制类型转换符`ChildClass c = (ChildClass)p`可以让c调用子类的成员变量

### instanceof关键字

为了避免在向下转型时,出现ClassCastException异常,使用`x instanceof A`可以判断x是否为A的对象

### Object类的使用

- Object只声明了一个空参构造器
- Object里没有属性
- 方法：
  - equals(Object obj)在没重写之前和==的作用相同,而String,Date,File,包装类重写了该方法,判断两个对象的属性是否相同 (==是运算符,用于基本数据类型时判断数值是否相等,用于引用数据类型时判断地址值是否相等)
  - toString()当输出一个对象引用时,默认调用对象的同toString方法,重写的该方法可以返回对象的内容(类型+[内容])

### 包装类(Wrapper)

针对八种基本数据类型定义相应的引用类型—包装类（封装类）:

|基本数据类型|包装类|
|---|---|
|byte|Byte|
|short|Short|
|int|Integer|
|long|Long|
|float|Float|
|double|Double|
|boolean|Boolean|
|char|Character|

```plantuml
digraph wrapper{
  rankdir = TB;
  基本数据类型 -> 包装类 [label = "包装类的构造器new\n或自动装箱:Integer t = 123;"];
  包装类 -> 基本数据类型 [label = "xxxintValue()\n或自动开箱:int i = t;"]
  基本数据类型 -> String[label = "1.连接运算符:\nString s = num + \"\";\n2.调用String.valueOf():\nString s = String.valueOf(t);"]
  String -> 基本数据类型 [label = "调用Xxx.ParseXxx:\nint i = Integer.ParseInteger(t)"]
  包装类 -> String [label = "toString()方法"]
  String -> 包装类 [label = "通过字符串参数"]
}
```

- JDK5.0新特性:自动装箱与自动开箱

## 面向对象的其他

### static关键字

用于修饰属性:静态变量,多个相同类的对象共享同一个静态变量.

- 静态变量随着类的加载而加载,可以通过`类.静态变量`调用
- 静态变量的加载早于对象的创建,只加载一次,存在于方法区的静态域中
- 类中的常量(final)通常也修饰为静态的

用于修饰方法:静态方法

- 静态方法随着类的加载而加载,可以通过`类.静态方法`调用
- 静态方法中,只能调用静态的属性和方法,不能调用this,super关键字,因为并没有创建类
- 工具类中的方法通常声明为静态的

### 单例设计模式

采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。

饿汉式:

```java
class Singleton {
// 1.私有化构造器
  private Singleton() {

  }
// 2.内部提供一个当前类的实例
// 4.此实例也必须静态化
  private static Singleton single = new Singleton();
// 3.提供公共的静态的方法，返回当前类的对象
  public static Singleton getInstance() {
    return single;
  }
}
```

懒汉式：

```java
class Singleton {
  private Singleton() {
  
  }

  private static Singleton single = null;

  public static Singleton getInstance() {
    if(single == null) {
      single = new Singleton();
    }
  return single;
  }
}
```

- 饿汉式对象的加载时间过长
- 懒汉式线程不安全

### main方法

- public:Java虚拟机需要调用该方法作为程序的入口
- static:使用该方法不必造一个对象
- void:没有返回值
- String[] args:接受String数组参数

### 代码块

对Java类或对象进行初始化

- 静态代码块:
  - 静态代码块随着类的加载而加载，且只执行一次。
  - 若有多个静态的代码块，那么按照从上到下的顺序依次执行。
  - 静态代码块的执行要先于非静态代码块。
- 非静态代码块:
  - 每次创建对象的时候，都会执行一次。且先于构造器执行。
  - 若有多个非静态的代码块，那么按照从上到下的顺序依次执行。

总结：程序中成员变量赋值的执行顺序

1. 声明变量的默认初始化
2. 由上到下依次执行显示初始化或代码块
3. 构造器中的初始化
4. 对象.属性或对象.方法赋值

### final关键字

- 修饰类:不能被继承
- 修饰方法:不能被重写
- 修饰变量:变成常量
  - 修饰属性:可以显式,在代码块,在构造器中赋值
  - 修饰局部变量:不能修改值

### abstract关键字

- 修饰类:抽象类,该类不能实例化
  - 该类中要有构造器便于子类实例化
- 修饰方法:抽象方法,只有方法的声明,没有方法体
  - 包含抽象方法的类一定是抽象类
  - 子类需要重写父类所有的抽象类,或子类也是一个抽象类

匿名类：

假如Person是一个抽象类且eat()是Preson中的所有抽象方法,以下可以定义一个匿名类.

```java
Person p = new Person(){
    @Override
    public void eat() {
      System.out.println("吃东西");
};
```

模板方法设计模式

### 接口

接口使用interface定义,定义了相同的行为特征;类通过实现(implements)接口的方式使用

接口中能定义:

- 全局变量(public static final),但是在代码中可以省略这些关键字
- 抽象方法(public abstract)

注意:

- 接口中没有构造器
- 接口与接口之间可以多继承
- 接口中也体现了多态性
- 也可以定义匿名实现类
- Java8在接口中还可以定义静态方法和默认(default)方法,接口中的静态方法只能接口使用,默认方法可以通过实现类的对象调用
- 如果实现类重写了接口中的默认方法,则调用的是重写后的方法;若实现类的父类声明了和接口中同名同参数的方法,那么在子类没有重写的情况下,默认调用父类的方法(类优先)
- 调用接口中被重写的方法:`接口名.super.方法`

```java
// 接口的多态性
interface USB{
  void start();
  void stop();
}

class Flash implements USB{
  @Override
  public void start() {
    System.out.println("U盘开启工作");
  }

  @Override
  public void stop() {
    System.out.println("U盘结束工作");
  }
}

class Computer{
  public void transferData(USB usb){//USB usb = new Flash();
    usb.start();
    //具体传输数据的细节
    usb.stop();
  }
}

```

代理设计模式,工厂设计模式

### 内部类

在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。

分类:

- 成员内部类(static和非static两种)
- 局部内部类

注意:

- 内部类可以直接使用外部类的所有成员，包括私有的数据
- 调用外部类`外部类.this.成员`
  
成员内部类:

- 与外部类不同,成员内部类还可以声明为private或protected的
- 非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声明static成员。

局部内部类:

- 只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类
- 但是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类的父类或父接口类型
- 当局部内部类使用外部方法的局部变量时,此局部变量应是final的

匿名内部类:

```java
new 父类构造器(实参列表) implements 实现接口 {
    //匿名内部类的类体部分
}
```
